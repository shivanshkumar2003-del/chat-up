
import { Chat } from "@google/genai";
import { UserProfile, Message } from "../types";
import { createMatchPersona, startChatSession, sendMessageToGemini } from "./geminiService";

export type ConnectionStatus = 'IDLE' | 'SEARCHING' | 'MATCHED' | 'CONNECTED' | 'DISCONNECTED' | 'ENDED';

export interface BackendEventCallbacks {
  onStatusChange: (status: ConnectionStatus) => void;
  onMessage: (msg: Message) => void;
  onPeerTyping: (isTyping: boolean) => void;
  onPeerFound: (name: string) => void;
}

/**
 * Acts as the WebSocket / Server Layer.
 * Handles matching logic, session management, and message transport.
 */
export class ChatBackend {
  private chatSession: Chat | null = null;
  private callbacks: BackendEventCallbacks;
  private userProfile: UserProfile;
  private isDestroyed = false;

  constructor(user: UserProfile, callbacks: BackendEventCallbacks) {
    this.userProfile = user;
    this.callbacks = callbacks;
  }

  public async startSearch() {
    if (this.isDestroyed) return;
    this.callbacks.onStatusChange('SEARCHING');
    
    // Quick search simulation (faster now so users don't wait for "real" people)
    const matchDelay = 1200; 
    
    setTimeout(async () => {
      if (this.isDestroyed) return;

      try {
        // 1. "Match" found in database (Generated by AI based on compatibility)
        this.callbacks.onStatusChange('MATCHED');
        const { systemInstruction, peerName } = await createMatchPersona(this.userProfile);
        
        this.callbacks.onPeerFound(peerName);
        
        // 2. Establish "P2P" Connection
        this.chatSession = startChatSession(systemInstruction);
        
        // Short delay to transition from Match -> Connect
        setTimeout(async () => {
             if (this.isDestroyed) return;
             this.callbacks.onStatusChange('CONNECTED');

             // 3. Trigger initial message from Peer
             this.callbacks.onPeerTyping(true);
             // We send a hidden prompt to the AI to start the conversation naturally
             const greeting = await sendMessageToGemini(this.chatSession, "The connection is open. Please start the conversation now based on your persona. Keep it short and natural.");
             
             if (!this.isDestroyed) {
                this.callbacks.onPeerTyping(false);
                this.callbacks.onMessage({
                    id: Date.now().toString(),
                    sender: 'peer',
                    text: greeting,
                    timestamp: new Date()
                });
             }
        }, 1000);

      } catch (e) {
        console.error("Match connection failed", e);
        this.callbacks.onStatusChange('DISCONNECTED');
      }
    }, matchDelay);
  }

  public async sendMessage(text: string) {
    if (!this.chatSession || this.isDestroyed) return;
    
    // Simulate network delay for AI processing
    this.callbacks.onPeerTyping(true);
    
    try {
        const response = await sendMessageToGemini(this.chatSession, text);
        
        if (!this.isDestroyed) {
            this.callbacks.onPeerTyping(false);
            this.callbacks.onMessage({
                id: Date.now().toString(),
                sender: 'peer',
                text: response,
                timestamp: new Date()
            });
        }
    } catch (err) {
        console.error("Message delivery failed", err);
        this.callbacks.onPeerTyping(false);
    }
  }
  
  public disconnect() {
    this.isDestroyed = true;
    this.chatSession = null;
    this.callbacks.onStatusChange('ENDED');
  }
}
